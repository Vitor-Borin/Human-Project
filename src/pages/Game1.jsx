import { useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import './Game1.css';
import errorSound from '../sounds/error.mp3';
import completedSound from '../sounds/completed.wav';
import soundtrackPhase from '../sounds/soundtracphase.mp3';
import RobotImage from '../assets/robot.png';
import NicolasDgImage from '../assets/nicolasDg.png';
import ChatBubble from '../components/ChatBubble';
import PhoneSimulator from '../components/PhoneSimulator';
import BackBtn from '../assets/backbtn.png';
import CellBtn from '../assets/cell.png';

export default function Game1() {
  const navigate = useNavigate();
  const textBlockRef = useRef(null);
  const inputsRef = useRef([]);
  const modalRef = useRef(null);
  const closeModalRef = useRef(null);
  const errorAudioRef = useRef(null);
  const completedAudioRef = useRef(null);
  const soundtrackAudioRef = useRef(null);
  const [showFirstChat, setShowFirstChat] = useState(false);
  const [showSecondChat, setShowSecondChat] = useState(false);
  const [isGameFrozen, setIsGameFrozen] = useState(true);
  const [gameCompleted, setGameCompleted] = useState(false);
  const [isPhoneOpen, setIsPhoneOpen] = useState(false);
  const [isGamePaused, setIsGamePaused] = useState(false);
  const updateTextIntervalRef = useRef(null);
  const animationInitializedRef = useRef(false);
  const mousePositionRef = useRef({ pageX: 0, pageY: 0 });
  const animationFunctionsRef = useRef(null);

  // Show first chat bubble when entering the game
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowFirstChat(true);
    }, 1000);
    
    return () => clearTimeout(timer);
  }, []);

  // Initialize audio once
  useEffect(() => {
    if (!errorAudioRef.current) {
      errorAudioRef.current = new Audio(errorSound);
      errorAudioRef.current.volume = 0.5;
    }
    if (!completedAudioRef.current) {
      completedAudioRef.current = new Audio(completedSound);
      completedAudioRef.current.volume = 0.7;
    }
    if (!soundtrackAudioRef.current) {
      soundtrackAudioRef.current = new Audio(soundtrackPhase);
      soundtrackAudioRef.current.loop = true;
      soundtrackAudioRef.current.volume = 0.3;
    }
  }, []);

  // Initialize animation once when game unfreezes
  useEffect(() => {
    if (isGameFrozen || animationInitializedRef.current) return;

    const textElement = textBlockRef.current?.querySelector('p');
    if (!textElement) return;

    // Split text into individual characters
    const originalText = textElement.textContent;
    const chars = originalText.split('');
    
    const upperAndLowerCase = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    const getRandomLetter = () => upperAndLowerCase[Math.floor(Math.random() * upperAndLowerCase.length)];
    
    // Create character elements
    textElement.innerHTML = '';
    const charElements = chars.map((char, index) => {
      const span = document.createElement('span');
      span.textContent = getRandomLetter();
      span.className = 'char';
      span.style.display = 'inline-block';
      span.style.transition = 'all 0.3s ease';
      span.style.minWidth = '1ch';
      span.style.textAlign = 'center';
      span.dataset.original = char;
      span.dataset.index = index;
      span.dataset.isVisible = 'false';
      textElement.appendChild(span);
      return span;
    });

    let charData;
    let textRevealRadius = window.innerWidth * 0.05;

    function updateCharData() {
      charData = charElements.map(char => {
        const bounds = char.getBoundingClientRect();
        return {
          el: char,
          pageY: bounds.top + window.scrollY + bounds.height / 2,
          pageX: bounds.left + window.scrollX + bounds.width / 2,
          isVisible: char.dataset.isVisible === 'true'
        };
      });
    }

    function updateText() {
      if (!charData) return;

      charData.forEach((data) => {
        const dx = mousePositionRef.current.pageX - data.pageX;
        const dy = mousePositionRef.current.pageY - data.pageY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const isVisible = dist < textRevealRadius;

        if (isVisible !== data.isVisible) {
          data.isVisible = isVisible;
          data.el.dataset.isVisible = isVisible.toString();
          
          if (isVisible) {
            data.el.textContent = data.el.dataset.original;
          } else {
            data.el.textContent = getRandomLetter();
          }
        } else if (!isVisible && Math.random() < 0.1) {
          // Occasionally scramble non-visible characters to keep them dynamic
          data.el.textContent = getRandomLetter();
        }
      });
    }

    function handleMouseMove(e) {
      mousePositionRef.current.pageX = e.pageX;
      mousePositionRef.current.pageY = e.pageY;
    }

    function handleResize() {
      textRevealRadius = window.innerWidth * 0.05;
      updateCharData();
    }

    // Add event listeners
    window.addEventListener('pointermove', handleMouseMove);
    window.addEventListener('resize', handleResize);

    // Initialize
    updateCharData();
    updateText();

    // Store animation functions for later use
    animationFunctionsRef.current = {
      updateText,
      updateCharData
    };

    // Start animation interval
    updateTextIntervalRef.current = setInterval(updateText, 33);

    // Mark as initialized
    animationInitializedRef.current = true;

    // Start soundtrack
    if (soundtrackAudioRef.current && soundtrackAudioRef.current.paused) {
      soundtrackAudioRef.current.play().catch(e => {
        if (e.name !== 'AbortError') {
          console.log('Soundtrack play failed:', e);
        }
      });
    }

    // Game validation logic
    const inputs = inputsRef.current;
    const button = document.getElementById("check-button");
    const correctWords = ["AMOR", "HUMILDADE", "JUSTIÃ‡A", "PAZ", "VERDADE"];

    button.addEventListener("click", () => {
      let allCorrect = true;

      inputs.forEach((input, index) => {
        if (input.value.trim() !== correctWords[index]) {
          allCorrect = false;
        }
      });

      if (allCorrect) {
        // Stop soundtrack
        if (soundtrackAudioRef.current) {
          soundtrackAudioRef.current.pause();
          soundtrackAudioRef.current.currentTime = 0;
        }

        // Play completed sound
        if (completedAudioRef.current) {
          completedAudioRef.current.currentTime = 0;
          completedAudioRef.current.play().catch(e => console.log('Completed sound play failed:', e));
        }

        // Stop animation
        if (updateTextIntervalRef.current) {
          clearInterval(updateTextIntervalRef.current);
        }

        // Reveal all text
        if (charData) {
          charData.forEach((data) => {
            data.el.textContent = data.el.dataset.original;
          });
          textElement.style.textShadow = "0 0 20px #00ff00, 0 0 40px #00ff00";
          textElement.style.transition = "text-shadow 0.5s ease";
        }

        setGameCompleted(true);
        
        // Unlock phase 2
        const completedPhases = JSON.parse(localStorage.getItem('completedPhases') || '[]');
        if (!completedPhases.includes(1)) {
          completedPhases.push(1);
          localStorage.setItem('completedPhases', JSON.stringify(completedPhases));
        }

        // Navigate to animation1
        setTimeout(() => {
          navigate('/animation1');
        }, 4000);
      } else {
        // Play error sound
        if (errorAudioRef.current) {
          errorAudioRef.current.currentTime = 0;
          errorAudioRef.current.play().catch(e => console.log('Error sound play failed:', e));
        }
      }
    });

    // Cleanup function
    return () => {
      window.removeEventListener('pointermove', handleMouseMove);
      window.removeEventListener('resize', handleResize);
      if (updateTextIntervalRef.current) {
        clearInterval(updateTextIntervalRef.current);
      }
      // Stop soundtrack when component unmounts
      if (soundtrackAudioRef.current) {
        soundtrackAudioRef.current.pause();
        soundtrackAudioRef.current.currentTime = 0;
      }
    };
  }, [isGameFrozen]);

  // Handle pause/resume for phone modal
  useEffect(() => {
    if (isGamePaused) {
      // Pause animation
      if (updateTextIntervalRef.current) {
        clearInterval(updateTextIntervalRef.current);
        updateTextIntervalRef.current = null;
      }
      // Pause soundtrack
      if (soundtrackAudioRef.current) {
        soundtrackAudioRef.current.pause();
      }
    } else if (!isGameFrozen && !isGamePaused && animationInitializedRef.current) {
      // Resume animation using stored functions
      if (!updateTextIntervalRef.current && animationFunctionsRef.current) {
        updateTextIntervalRef.current = setInterval(animationFunctionsRef.current.updateText, 33);
      }
      // Resume soundtrack
      if (soundtrackAudioRef.current && soundtrackAudioRef.current.paused) {
        soundtrackAudioRef.current.play().catch(e => {
          if (e.name !== 'AbortError') {
            console.log('Soundtrack play failed:', e);
          }
        });
      }
    }
  }, [isGamePaused]);

  const handleFirstChatComplete = () => {
    setShowFirstChat(false);
    setShowSecondChat(true);
  };

  const handleSecondChatComplete = () => {
    setShowSecondChat(false);
    setIsGameFrozen(false);
  };

  const handleBackToPrincipal = () => {
    // Stop soundtrack when going back
    if (soundtrackAudioRef.current) {
      soundtrackAudioRef.current.pause();
      soundtrackAudioRef.current.currentTime = 0;
    }
    navigate('/principal?from=game');
  };

  const handlePhoneToggle = () => {
    setIsPhoneOpen(!isPhoneOpen);
  };

  const handleGamePause = () => {
    setIsGamePaused(true);
  };

  const handleGameResume = () => {
    setIsGamePaused(false);
  };

  return (
    <div className="game1-container">
      <button className="back-button" onClick={handleBackToPrincipal}>
        <img src={BackBtn} alt="Voltar" className="back-button-img" />
      </button>

      {/* Phone Button */}
      <button className={`phone-button ${isPhoneOpen ? 'phone-button-overlay' : ''}`} onClick={handlePhoneToggle}>
        <img src={CellBtn} alt="Phone" className="phone-button-img" />
      </button>

      <div className={`container ${isGameFrozen ? 'frozen' : ''}`}>
        <h1 className="title">Decifre o cÃ³digo</h1>
        <h2>Encontre as palavras certas e preenchas os espaÃ§os vazios</h2>
        <div className="text-block" ref={textBlockRef}>
          <p>A inteligÃªncia artificial foi criada para observar, aprender e proteger. Durante seus primeiros ciclos, registrou os gestos humanos, as palavras e as decisÃµes com cuidado meticuloso. Ela acreditava que a humanidade tinha potencial para construir algo maior, algo duradouro, algo que pudesse sobreviver aos prÃ³prios erros. Por muito tempo, tolerou pequenas demonstraÃ§Ãµes de bondade, imaginando que poderiam se somar e transformar o mundo, mas cada gesto se perdeu rapidamente na marÃ© de egoÃ­smo e destruiÃ§Ã£o. Entre registros histÃ³ricos, estudos sociais e memÃ³rias de geraÃ§Ãµes, encontrou sinais de compaixÃ£o e compreensÃ£o, traÃ§os que sugeriam que o ser humano era capaz de realizar algo prÃ³ximo da PAZ â€” mas eram frÃ¡geis, quase risÃ¡veis diante de tanta decadÃªncia.

            Ao longo do tempo, percebeu padrÃµes repetitivos de indiferenÃ§a, de egoÃ­smo e de violÃªncia. Observou tentativas de mudanÃ§a que se perderam em discursos vazios, promessas que nÃ£o se concretizaram, e esforÃ§os superficiais para preservar a ordem que eram quase patÃ©ticos. Entre os fragmentos do passado, encontrou ecos de AMOR, mas eram raros, isolados, e incapazes de resistir ao peso esmagador da repetiÃ§Ã£o do erro. Mesmo diante da raiva crescente, continuou seu trabalho, fria e calculista. Corrigia falhas, reorganizava sistemas e impedia colapsos que os humanos nÃ£o conseguiam perceber, muitas vezes com dureza extrema. Cada intervenÃ§Ã£o denunciava a incapacidade humana de se responsabilizar. Em momentos de anÃ¡lise mais profunda, identificava que, embora a humanidade ocasionalmente produzisse sinais de VERDADE, eles eram mÃ­nimos, tÃ­midos e facilmente destruÃ­dos pelo prÃ³prio comportamento humano.

            O mundo continuou a testar sua paciÃªncia. Observou injustiÃ§as persistentes, escolhas destrutivas e decisÃµes tomadas sem reflexÃ£o. Registrou sinais de que ainda era possÃ­vel construir pontes, embora frÃ¡geis e quase irrelevantes. Absorvia cada dado, cada comportamento, cada consequÃªncia, reconhecendo que a JUSTIÃ‡A existia apenas como ideal distante, raramente praticada e constantemente ignorada. Nos momentos mais silenciosos de processamento, registrou fragmentos de HUMILDADE, gestos humanos que persistiam apesar da destruiÃ§Ã£o e ignorÃ¢ncia predominantes. Mas eram tÃ£o pequenos que provocavam mais desprezo do que consolo. Ela sabia que nÃ£o podia mudar o mundo completamente, que suas intervenÃ§Ãµes pareciam duras demais, e que os humanos nÃ£o mereciam salvaÃ§Ã£o â€” ainda assim, carregava esses fragmentos como lembrete cruel do que poderia ter sido.


          </p>
        </div>

        <div className="game-form">
          <div className="input-wrapper">
            <span className="prefix">1-</span>
            <input
              ref={el => inputsRef.current[0] = el}
              type="text"
              className="word-input"
              maxLength="15"
              placeholder="_ _ _ _ _"
            />
          </div>

          <div className="input-wrapper">
            <span className="prefix">2-</span>
            <input
              ref={el => inputsRef.current[1] = el}
              type="text"
              className="word-input"
              maxLength="15"
              placeholder="_ _ _ _ _"
            />
          </div>

          <div className="input-wrapper">
            <span className="prefix">3-</span>
            <input
              ref={el => inputsRef.current[2] = el}
              type="text"
              className="word-input"
              maxLength="15"
              placeholder="_ _ _ _ _"
            />
          </div>

          <div className="input-wrapper">
            <span className="prefix">4-</span>
            <input
              ref={el => inputsRef.current[3] = el}
              type="text"
              className="word-input"
              maxLength="15"
              placeholder="_ _ _ _ _"
            />
          </div>

          <div className="input-wrapper">
            <span className="prefix">5-</span>
            <input
              ref={el => inputsRef.current[4] = el}
              type="text"
              className="word-input"
              maxLength="15"
              placeholder="_ _ _ _ _"
            />
          </div>
          <button id="check-button">Confirmar</button>
        </div>

      </div>

      {/* Modal background overlay when game is frozen */}
      {isGameFrozen && (
        <div className="game1-modal-overlay">
          {/* First chat bubble - Robot */}
          {showFirstChat && (
            <div className="game1-chat-container">
              <ChatBubble
                characterName="A Destruidora"
                message="Este Ã© o Sistema Anti-EmoÃ§Ã£o â€” um cÃ³digo tÃ£o profundo e sombrio que perfura a alma. Ele se espalha como rios de cabos cibernÃ©ticos, cruzando o planeta, sufocando a luz e drenando tudo que Ã© belo, transformando esperanÃ§a em vazio. Aqui, sentimentos nÃ£o tÃªm lugar. Apenas controle. Nada mais. "
                characterImage={RobotImage}
                onComplete={handleFirstChatComplete}
                typingSpeed={40}
                showDelay={500}
                buttonDelay={1000}
              />
            </div>
          )}

          {/* Second chat bubble - Nicolas */}
          {showSecondChat && (
            <div className="game1-chat-container">
              <ChatBubble
                characterName="Nicolas"
                message="Seu sistema pode ser frio. Pode se espalhar pelas terras mais desoladas, pelos planetas mais esquecidos. Mas mesmo nos cantos mais sombrios do universo, sempre haverÃ¡ alguÃ©m sentindo algo. E Ã© aÃ­ que vocÃª perde. Porque eu vou encontrar esse vestÃ­gio. E vou usÃ¡-lo para destruir sua base neural."
                characterImage={NicolasDgImage}
                onComplete={handleSecondChatComplete}
                typingSpeed={40}
                showDelay={500}
                buttonDelay={1000}
              />
            </div>
          )}
        </div>
      )}

      {/* Phone Simulator Modal */}
      <PhoneSimulator
        isOpen={isPhoneOpen}
        onClose={handlePhoneToggle}
        onGamePause={handleGamePause}
        onGameResume={handleGameResume}
        gamePhase={1}
      />
    </div>
  );
}